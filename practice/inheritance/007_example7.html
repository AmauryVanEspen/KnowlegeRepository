<html>
<script>
function SuperType(name22){
    this.name = name22;
    this.colors = ["red","blue","green"];
}

SuperType.prototype.sayName = function(){
    alert(this.name);
};

function SubType(name22,age){
    SuperType.call(name22);//第二次调用SuperType()
    this.age = age;
}

SubType.prototype = new SuperType();//第一次调用SuperType()

SubType.prototype.sayAge = function(){
   alert(this.age); 
};

var jerry = new SubType("Jerry", 20);
/*
第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和colors，它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。

Result: name没有办法传到jerry实例上。
*/

</script>
</html>