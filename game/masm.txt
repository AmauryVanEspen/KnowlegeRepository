这篇文章是要提醒自己，千万要注意细微[这个词用词不当]的差别！ 
在Code::Block里写了个2D/1D的动规，贴到VC7里打死答案不对，身为MS忠实的Fans，一定要找到原因！ 
结果两个结论： 
1.MS VS2005 pro里面的调试符号是有问题滴！尤其是非托管的bss数据，俄！估计是调试线程的开发有问题，不过，有bugs是正常的，才有提高的空间嘛！[只有我这种LLV还在用win32,大虾都跑去玩P/Invoke了，害我白出一身汗] 
2.MS cl.exe[Intel策略编译器]和GNU gcc.exe的差别要注意，不然很容易犯错[这个词用错了，其实不算错！编译策略嘛，大家有权利修改自己认为最好的策略] 

好了，平易起见，把遇到的问题“简单化”，贴出来！以后免得又以为自己算法写错了！ 
#include <stdio.h> 
int main() 
{ 
int z=3;   
z=(++z)+(++z)+(++z); 
printf("%d\n",z); 
return 0;   
} 
cl.exe编译后的test.asm: 
; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 
; Generated by VC++ for Common Language Runtime 
.file "C:\Users\orlando\Desktop\DevLink\test.cpp" 
.rdata 
$SG7097: 
.ascii "%d\n\000" 
.bss 
.local $T7116,0 
.local [email=$VarArgTok$1$$$A6AHPBDH@Z,4]$VarArgTok$1$$$A6AHPBDH@Z,4[/email] 
; Function compile flags: /Odtp 
.text 
.global [email=?main@@$$HYAHXZ]?main@@$$HYAHXZ[/email]     ; main 
[email=?main@@$$HYAHXZ]?main@@$$HYAHXZ[/email]:     ; main 
; .proc.def D:I() 
; Function Header: 
; max stack depth = 2 
; function size = 38 bytes 
; local varsig tk = 0x11000001 
; Exception Information: 
; 0 handlers, each consisting of filtered handlers 
; .local.i4 0,"_z$" SIG: i4 
; .local.i4 1,"$T7115" SIG: i4 
; .proc.beg 
; File c:\users\orlando\desktop\devlink\test.cpp 
; Line 5 
ldc.i.0  0  ; i32 0x0 
stloc.1    ; $T7115 
ldc.i.3  3  ; i32 0x3 
stloc.0    ; _z$ 
; Line 6 
ldloc.0    ; _z$ 
ldc.i.1  1  ; i32 0x1 
add   
stloc.0    ; _z$ 
ldloc.0    ; _z$ 
ldc.i.1  1  ; i32 0x1 
add   
stloc.0    ; _z$ 
ldloc.0    ; _z$ 
ldc.i.1  1  ; i32 0x1 
add //MS解释的双字操作 
stloc.0    ; _z$ 
ldloc.0    ; _z$ 
dup   
add //加和 
ldloc.0    ; _z$ 
add //加和 
stloc.0    ; _z$ 
; Line 7 
ldsflda  $SG7097 
ldloc.0    ; _z$ 
call  [email=?printf@@$$J0YAHPBDZZ]?printf@@$$J0YAHPBDZZ[/email] 
pop   
; Line 8 
ldc.i.0  0  ; i32 0x0 
stloc.1    ; $T7115 
; Line 9 
ldloc.1    ; $T7115 
ret   
.end [email=?main@@$$HYAHXZ]?main@@$$HYAHXZ[/email]     ; main 
; .proc.end.i4 
_TEXT ENDS 
PUBLIC [email=__mep@?main@@$$HYAHXZ]__mep@?main@@$$HYAHXZ[/email] 
PUBLIC _main 
; COMDAT [email=__mep@?main@@$$HYAHXZ]__mep@?main@@$$HYAHXZ[/email] 
data SEGMENT 
[email=__mep@?main@@$$HYAHXZ]__mep@?main@@$$HYAHXZ[/email] TOKEN 0A000009 
; Function compile flags: /Odtp 
data ENDS 
; COMDAT _main 
_TEXT SEGMENT 
_main PROC      ; COMDAT 
jmp DWORD PTR [email=__mep@?main@@$$HYAHXZ]__mep@?main@@$$HYAHXZ[/email] 
_main ENDP 
_TEXT ENDS 
END 
gcc.exe编译后的test.asm: 
.file "test.cpp" 
.def ___main; .scl 2; .type 32; .endef 
.section .rdata,"dr" 
LC0: 
.ascii "%d\12\0" 
.text 
.align 2 
.globl _main 
.def _main; .scl 2; .type 32; .endef 
_main: 
pushl %ebp 
movl %esp, %ebp 
subl $24, %esp 
andl $-16, %esp 
movl $0, %eax 
addl $15, %eax 
addl $15, %eax 
shrl $4, %eax 
sall $4, %eax 
movl %eax, -8(%ebp) 
movl -8(%ebp), %eax 
call __alloca 
call ___main 
movl $3, -4(%ebp) 
leal -4(%ebp), %eax 
incl (%eax) 
leal -4(%ebp), %eax 
incl (%eax)//双元加和 
movl -4(%ebp), %eax 
movl -4(%ebp), %edx//z=5 
addl %eax, %edx//两项求和 
leal -4(%ebp), %eax 
incl (%eax)//最后一次递增z=6 
leal -4(%ebp), %eax 
addl %edx, (%eax)//最终求和z=16 
movl -4(%ebp), %eax 
movl %eax, 4(%esp) 
movl $LC0, (%esp) 
call _printf 
movl $0, %eax 
leave 
ret 
.def _printf; .scl 2; .type 32; .endef 

PS：AT&T的汇编规定的有点奇怪，不过呢，AT&T的创始人牛嘛！呵呵，不然怎么能把自己的生日都写到PE规范里面去了呢！ 
PS：MS的那个也有点奇怪，估计是我开了/clr的原因吧！下次不干这种傻事了！ 
走远了，我还是继续研究那个2D/1D的算法了，呵呵，比较有趣的咚咚！原来数学情节太浓，看到函数就开始兴奋！ 

俄！~~贴在这里莫忘记了！今天居然把cl.exe和lc.exe搞混了，一翻MSDN，差点吐血了！ 
LLV真的很傻很天真，lc.exe都提示你“.net policy”了，都还在想郎格编译不出.o呢！ 
完都完料！ 

LLV吐血结帖中！ 